# 📦 Тема 1.11 - this.setState в классовых компонентах

---

## 🔹 Краткое описание

`this.setState` — это специальный метод в классовых компонентах React, который используется для изменения состояния (state).
В отличие от прямого изменения this.state, он автоматически вызывает перерендер и работает асинхронно.

---

## 🔹 Основные моменты

### 🚫 Нельзя менять state напрямую

```javascript
// ❌ так не работает
this.state.count++;

// ✅ правильно
this.setState({ count: this.state.count + 1 });
```

> 📌 Прямое изменение state не вызовет перерендер, а setState — вызовет.

### ⚡ Асинхронность обновлений

React может объединять несколько вызовов `setState` в один батч.

```javascript
// ❌ увеличит только на +1
this.setState({ count: this.state.count + 1 });
this.setState({ count: this.state.count + 1 });

// ✅ правильно
this.setState((prev) => ({ count: prev.count + 1 }));
this.setState((prev) => ({ count: prev.count + 1 }));
```

> 📌 Используй функцию с prevState, если новое значение зависит от предыдущего.

### 🔄 Функция в setState

setState может принимать не только объект, но и функцию:

```javascript
this.setState((prevState, props) => ({
  count: prevState.count + props.step,
}));
```

> 📌 Это удобно, когда новое состояние зависит от props и старого state.

### 🎯 Колбэк после обновления

Если нужно выполнить действие сразу после изменения state:

```javascript
this.setState({ count: 10 }, () => {
  console.log("State обновлён:", this.state.count);
});
```

---

## 🔹 Практическая польза

- Правильное обновление состояния в классах.
- Избежание багов при работе с асинхронным обновлением state.
- Возможность делать действия после обновления состояния.

---

## ⚠️ Подводные камни

| Ошибка                                   | Почему плохо                            | Решение                                                      |
| ---------------------------------------- | --------------------------------------- | ------------------------------------------------------------ |
| `this.state.value = 1`                   | State не обновится, перерендер не будет | Использовать `this.setState({ value: 1 })`                   |
| Несколько вызовов подряд без `prevState` | Берётся устаревшее значение             | Использовать функцию `setState(prev => ...)`                 |
| Нет действий после изменения             | Логика выполняется раньше обновления    | Передавать колбэк: `this.setState(..., () => { /* ... */ })` |
